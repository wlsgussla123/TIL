# 자바 클래스로더
클래스 로더란, 자바 바이트 코드를 jvm으로 동적 로드하는 jre의 일부이다.
* 자바의 write once, run anywhere를 행할 수 있게 한 기술이라 볼 수 있다.
	1. java compiler를 통해 .java 파일을 자바 바이트 코드로 컴파일
	2. 바이트 코드를 jvm의 class loader에 전달
	3. class loader는 동적 로딩으로 필요한 클래스를 로딩 및 링크하여 runtime data area (메모리 영역)에 올린다.
	4. 실행엔진 (execution engine)은 jvm 메모리에 올라온 byte code들을 명령어 단위로 하나씩 가져와서 실행한다.

## 클래스 로더의 특징
* 구조가 계층적이다.
	* 상위 클래스 로더에서 하위 클래스 로더를 갖는 방식
		* 최상위 클래스 로더는 부트스트랩 클래스 로더
* 클래스 로딩을 delegation할 수 있음
* 클래스 로더는 로딩이 가능한 범위가 있다.
	*	자식 클래스 로더는 클래스 로딩 요청 위임을 통해 부모 클래스 로더가 로딩한 클래스를 찾을 수 있지만, 부모 클래스 로더는 자식 클래스 로더가 로딩한 클래스를 알 수 없다.
* 클래스 언로딩이 불가능
	* gc가 동작하거나 was가 재시작할 때 초기화 된다.
* 클래스 로더는 라이브러리를 위치시키고 내용물을 읽으며 라이브러리들 안에 포함된 클래스들을 읽는다.
	* 로딩은 일반적으로 요청이 오면 동작하는데, 이 말은 클래스가 프로그램에 의해 호출될 때까지 로드되지 않는다는 것을 뜻

## 클래스 로더 delegation model
Execution engine은 바이트 코드를 실행하다가, 처음으로 참조하는 클래스에 대해 클래스 로더에 요청할 때, 혹은 클래스 로더가 클래스를 로드할 때 요청 받은 클래스가 있는지 확인한다.
* 클래스 로더 캐시
* 상위 클래스 로더
* 클래스 로더 자기 자신
	* 부트스트랩 로더까지 갔음에도 없을 경우 파일 시스템에서 해당 클래스를 찾는다
		* 없으면 ClassNotFoundException이..

## 클래스 로더의 유형
* 부트스트랩 클래스 로더
	* JVM 런타임 실행을 위해 기반이 되는 파일들을 로드한다.
* 확장 클래스 로더
	* Object를 포함한 자바 API를 로드한다.
* 시스템 클래스 로더
	* classpath에 포함된 클래스들을 로드한다.
* 사용자 정의 클래스 로더 
	* 어플리케이션 사용자가 직접 코드상에서 생성하여 사용하는 클래스로더
* WAS
	* 독립적인 영역이 필요하기 떄문에 시스템 클래스 로더 하위에 사용자 정의 로더를 만들어서 사용한다.
		* 사용자  정의 클래스 로더들을 사용하여 클래스 로더의 위임 모델을 통해 어플리케이션의 독립성을 보장.
		* 대부분 톰캣 설치 위치를 CATALINA_HOME으로 지정하는 것은 WAS에서 생성한 클래스 로더를 기준으로 동작하기 위함

## Name Space
* 각 클래스 로더들이 갖고 있는 공간
	* 로드된 클래스들을 보관하는 공간
	* 위임 모델을 통해 상위 클래스 로더를 확인할 때, 이 이름 공간을 확인한다.


## 클래스 로딩 과정
* 로딩
	* 클래스 파일을 바이트 코드로 읽어 메모리로 가져오는 과정
* 링크 : 클래스 또는 인터페이스를 가져 와서 jvm의 런타임 상태로 결합하여 실행되도록하는 프로세스.
	* 검증
		* 클래스 로드 과정에서 가장 복잡하고 시간 많이 걸림
		* 읽어들인 클래스가 자바 언어 명세 및 jvm 명세에 맞는지 검증
	* 준비
		* 클래스가 필요로 하는 메모리 할당
	* 분석
		
* 초기화
	* 슈퍼 클래스 및 정적 필드를 초기화
